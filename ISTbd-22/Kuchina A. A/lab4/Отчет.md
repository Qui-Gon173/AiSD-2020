## Лабораторная работа  №4
### Тема: Реализовать пирамидальный алгоритм сортировки.  
### Задание: На языке C++ реализовать пирамидальный алгоритм сортировки.

## Код программы:  
```c++
int parent(int i) {
	return i / 2;
}

int left(int i) {
	return (2 * i + 1);
}

int right(int i) {
	return (2 * i + 2);
}

void max_pyramid(int array[], int size, int i) {
	int l = left(i);
	int r = right(i);
	int largest = 0;
	if (l < size && array[l] > array[i])
		largest = l;
	else largest = i;
	if (r < size && array[r] > array[largest])
		largest = r;
	if (largest != i) {
		array[i] += array[largest];
		array[largest] = array[i] - array[largest];
		array[i] -= array[largest];
		max_pyramid(array, size, largest);
	}
}

void build_max_heap(int array[], int size) {
	for (int i = size / 2; i >= 0; --i) {
		max_pyramid(array, size, i);
	}
}

void heap_sort(int array[], int size) {
	build_max_heap(array, size);
	for (int i = size - 1; i >= 0; --i) {
		array[i] += array[0];
		array[0] = array[i] - array[0];
		array[i] -= array[0];
		size -= 1;
		max_pyramid(array, size, 0);
	}
}
```

## Контрольные вопросы:  
<strong> № 1. Что такое бинарное сортирующее дерево?</strong>    
Бинарное дерево - это структура данных дерева, в которой каждый родительский узел может иметь не более двух дочерних элементов.  
№ 2. Суть пирамидального алгоритма сортировки.    
Общая идея пирамидальной сортировки заключается в том, что сначала строится пирамида из элементов исходного массива, а затем осуществляется сортировка элементов.
№ 3. В чем разница устойчивой и неустойчивой сортировки?    
Устойчивость сортировки всегда может быть достигнута путём удлинения исходных ключей, если включить в них информацию об первоначальном порядке значений.
№ 4. Достоинства и недостатки  
Достоинства:  
· Имеет доказанную оценку худшего случая O(n*log(n)).

Недостатки:  
· Сложен в реализации.  
· Неустойчив - для обеспечения устойчивости нужно расширять ключ.  
· На почти отсортированных массивах работает столь же долго, как и на хаотических данных.  
· На одном шаге выборку приходится делать хаотично по всей длине массива -- поэтому алгоритм плохо сочетается с кэшированием и подкачкой памяти.



