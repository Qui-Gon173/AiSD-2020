# <strong>Лабораторная работа №4  <strong>#
## <strong>"Реализовать пирамидальный алгоритм сортировки." <strong> 
## Задание: На языке C++ реализовать пирамидальный алгоритм сортировки.
### Исходный код:  
``` c++
void heapify(int arr[], int n, int i) {
	int largest = i;
	int l = 2 * i + 1; //лев
	int r = 2 * i + 2; //прав

	if (l < n && arr[l] > arr[largest]) {
		largest = l;
	}
	if (r < n && arr[r] > arr[largest]) {
		largest = r;
	}
	if (largest != i)
	{
		std::swap(arr[i], arr[largest]);
		heapify(arr, n, largest);
	}
}

void heapSort(int arr[], int n) {
	//строим кучку
	for (int i = n / 2 - 1; i >= 0; i--) {
		heapify(arr, n, i);
	}
	//уменьшаем кучку
	for (int i = n - 1; i >= 0; i--) {
		std::swap(arr[0], arr[i]);
		heapify(arr, i, 0);
	}
}
```  
## Вопросы к лабораторной работе №4  
1. *Что такое бинарное сортирующее дерево?*  
	Это такое двоичное дерево, для которого выполнены три условия:
		1.Значение в любой вершине не меньше, чем значения её потомков.  
		2.Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.  
		3.Последний слой заполняется слева направо без «дырок». 
2. 	*Суть пирамидального алгоритма сортировки*  
	Мы строим maxheap из введённого массива, после чего заменяем самый большой элемент, находящийся в корне кучи, на последний элемент кучи, а затем уменьшаем её размер на 1. И повторяем эти шаги, пока размер кучи не станет равным 1.
3.	*В чем разница устойчивой и неустойчивой сортировки?*    
	 При неустойчивой сортировке теряется порядок элементов, имеющих одинаковые ключи, этим страдают сортировки пирамидой и методом Хоара. При устойчивой сортировке относительный порядок элементов с одинаковыми ключами сохраняется. 
4. *Достоинства*  
	1. Имеет доказанную оценку худшего случая ``` o(n*log(n)) ```  
	2. Малое количество требуемой дополнительной памяти
5. *Недостатки*  
	1. Неустойчив — для обеспечения устойчивости нужно расширять ключ.  
	2. На почти отсортированных массивах работает столь же долго, как и на хаотических данных.  
	3. На одном шаге выборку приходится делать хаотично по всей длине массива — поэтому алгоритм плохо сочетается с кэшированием и подкачкой памяти.  
	4. Методу требуется «мгновенный» прямой доступ; не работает на связанных списках и других структурах памяти последовательного доступа.