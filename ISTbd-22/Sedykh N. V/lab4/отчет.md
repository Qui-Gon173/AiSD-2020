# Отчет по лабораторной работе №4

### Исходный код:
```
#include <iomanip>
#include <iostream>

using namespace std;

void filling_array_random(int array[], int quantity)
{
    srand((unsigned)time(0));
    for (int i = 0; i < quantity; i++)
    {
        array[i] = rand() % 10;
    }
}

void array_output(int array[], int quantity)
{
    for (int i = 0; i < quantity; i++)
    {
        cout << array[i] << " ";
    }
    cout << endl;
}

void heap(int array[], int quantity, int i)
{
    int largest = i;

    int l = 2 * i + 1;
    int r = 2 * i + 2;
    
    if ((l < quantity) && (array[l] > array[largest])) largest = l;
    
    if ((r < quantity) && (array[r] > array[largest])) largest = r;

    if (largest != i)
    {
        swap(array[i], array[largest]);
        heap(array, quantity, largest);
    }
}

void sort_heap(int array[], int quantity)
{
    for (int i = quantity / 2 - 1; i >= 0; i--)
        heap(array, quantity, i);

    for (int i = quantity - 1; i > 0; i--)
    {
        swap(array[0], array[i]);
        heap(array, i, 0);
    }
}

int main()
{ 
    int quantity;

    cout << "Enter the number of elements in the array: ";
    cin >> quantity;

    int* array = new int[quantity];

    filling_array_random(array, quantity);
    
    cout << "Array: ";
    array_output(array, quantity);

    sort_heap(array, quantity);

    cout << "Sorted array: ";
    array_output(array, quantity);
}
```
## Ответы на вопросы
### Что такое бинарное сортирующее дерево?
Бинарное дерево поиска - бинарное дерево из элементов, где ключ элемента в каждой вершине больше ключей всех элементов 
левого поддерева и меньше ключей элементов правого поддерева.В корне будет находиться элемент со средним индексом, элементы со 
средними индексами верхней и нижней половин таблицы составят значения левого и правого сыновей корня, следующий уровень 
вершин составят средние элементы всех четвертей таблицы и так далее.
### Суть пирамидального алгоритма сортировки
Сначала строится пирамида из элементов исходного массива, а затем осуществляется сортировка элементов. 
Определяем правую часть дерева, начиная с n/2-1. Далее берем элемент левее этой части массива и 
просеиваем его сквозь пирамиду по пути, где находятся меньшие его элементы, 
которые одновременно поднимаются вверх; из двух возможных путей выбираем путь через меньший элемент. 
Берем последний элемент массива в качестве текущего. Меняем верхний (наименьший) элемент массива и текущий местами. 
Текущий элемент (он теперь верхний) просеиваем сквозь n-1 элементную пирамиду. Затем берем предпоследний элемент и т.д. 
### В чем разница устойчивой и неустойчивой сортировки?
Устойчивая сортировка — сортировка, которая не меняет "местами" эквивалентные элементы.
Некоторые алгоритмы сортировки стабильны по своей природе, например, сортировка вставки, сортировка слияния, сортировка 
пузырьков и т. д. И некоторые алгоритмы сортировки не являются такими, как сортировка кучи, быстрая сортировка и т. д.
### Достоинства и недостатки
Достоинства - имеет доказанную оценку худшего случая O(n \log n), требует всего O(1) дополнительной памяти.
Недостатки - сложен в реализации, неустойчив, на почти отсортированных массивах работает столь же долго, как и на хаотических данных.