# Отчет по лабораторной работе №8.1
## Вариант 2,6
### Исходный код
Файл lab8.1.cpp
```
#include <iostream>
#include "Stack.cpp"
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");

    int stackSize;
    cout << "Введите количество элементов в стеке: ";
    cin >> stackSize;

    Stack *stack = new Stack(stackSize);
    stack->generate();

    cout << "Сгенерированный стек: ";
    stack->printStack();

    float newElements[4] = {2.3, 33, 1.4, 10};
    stack->pushElements(newElements, 4);
    cout << "Стек с добавленными элементами: ";
    stack->printStack();

    cout << "Вершина стека: ";
    cout << stack->topElement() << endl;

    cout << "Количество элементов в стеке: ";
    cout << stack->numberElements() << endl;

    cout << "Сумма элементов стека: ";
    cout << stack->sumElements() << endl;

    cout << "Среднее значение элементов стека: ";
    cout << stack->meanValue() << endl;

    cout << "Минимальный элемент в стеке: ";
    cout << stack->minElement() << endl;

    cout << "Максимальный элемент в стеке: ";
    cout << stack->maxElement() << endl;

    int poppingElementsNumber;
    cout << "Введите количество элементов для удаления: ";
    cin >> poppingElementsNumber;

    float poppedTElement;
    float* newArray = new float[poppingElementsNumber];

    if (poppingElementsNumber == 1) 
        poppedTElement = stack->pop();
    else 
    {
        newArray = stack->popMultipleElements(poppingElementsNumber);
    }
    cout << "Стэк с удалленными элементами: ";
    stack->printStack();

    cout << "Удаленные элементы добаляются в новый стек:  ";
    Stack* secondStack = new Stack();
    secondStack->pushElements(newArray, poppingElementsNumber);
    secondStack->printStack();
}
```
Файл Stack.cpp
```
#include <iostream>
#include <ctime>
#include <vector>

using namespace std;

class Stack {

private:
	int stackSize;
	int topIndex;
	std::vector<float> stackElements;

public:
	//Конструтор стека
	Stack(int size=0)
	{
		stackSize = size;
		topIndex = 0;
	};

	//Заполнение стека рандомными числами типа float
	void generate()
	{
		srand((unsigned)time(0));
		for (int i = 0; i < stackSize; i++) {
			float fl = rand() % 10;
			stackElements.push_back(fl);
		}
		resizeStackAttributes();
	}

	//Изменение размера стека и вершины стеа
	void resizeStackAttributes()
	{
		stackSize = stackElements.size();
		topIndex = stackSize - 1;
	}

	//Добавление элементов в стек
	void push(float newElement)
	{
			stackElements.push_back(newElement);
			resizeStackAttributes();
	}

	void pushElements(float* array, int length)
	{
		for (int i = 0; i < length; i++)
			push(array[i]);
	}

	//Вывод стека
	void printStack()
	{
		for (int i = topIndex; i >= 0; i--)
			cout << stackElements[i] << " ";
		cout << endl;
	}

	//Вершина стека
	float topElement()
	{
		return stackElements[topIndex];
	}

	//Отчистка стека
	void clearStack()
	{
		this->topIndex = 0;
	}

	//Количество элементов в стеке
	int numberElements()
	{
		return stackSize;
	}

	//Сумма элементов стека
	float sumElements()
	{
		int sum = 0;
		for (int i = 0; i < topIndex; i++)
			sum += stackElements[i];
		return sum;
	}

	//Среднее значение
	float meanValue()
	{
		if (topIndex > 0)
			return (float)this->sumElements() / (float)topIndex;
		else
			return 0;
	}

	//Минимальный элемент
	float minElement()
	{
		if (topIndex > 0)
		{
			int min = stackElements[0];
			for (int i = 0; i < topIndex; i++)
				if (min > stackElements[i])
					min = stackElements[i];
			return min;
		}
		else
			return 0;
	}

	//Максимальный элемент
	float maxElement()
	{
		if (topIndex > 0)
		{
			int max = stackElements[0];
			for (int i = 0; i < topIndex; i++)
				if (max < stackElements[i])
					max = stackElements[i];
			return max;
		}
		else
			return 0;
	}

	//Удаление элементов из стека
	float pop()
	{
		float lastElement = stackElements[topIndex];
		stackElements.pop_back();
		resizeStackAttributes();

		return lastElement;
	}

	float* popMultipleElements(int poppingElementsNumber)
	{
		if (poppingElementsNumber > stackSize)
		{
			cout << "Количество элементов для удаления больше размера стека!";
			exit(0);
		}

		float *poppedArray = new float[poppingElementsNumber];
		for (int i = 0; i < poppingElementsNumber; i++)
			poppedArray[i] = pop();

		return poppedArray;
	}
};
```
## Ответы на вопросы
### Определение и особенности контейнера стек
Стек - упорядоченный набор элементов, где размещение 
новых и удаление существующих происходит с одного конца, называемого вершиной.
Стек состоит из ячеек, которые представлены в виде структуры, содержащей какие-либо 
данные и указатель типа данной структуры на следующий элемент.
Особенность стека является то, что список элементов реализован по принципу LIFO 
(last in — first out, «последним пришёл — первым вышел»).
### Преимущества и недостатки контейнера стек
Достоинства - добавление элемента всегда работает за одно и тоже время
(т.к. нет необходимости компировать весь стек, если вдруг кончится память).
Недостатки - можно перемещаться по стеку лишь в одном направлении, это затрудняет 
поиск необходимого элемента.
### Оценка сложности по добавлению, удалению и поиску элемента в коллекции контейнера стек
Добавление элемента в вершину стека (push) - O(1).
Удаление элемента из вершины стека и возврат его (pop) - O(1).
Возврат количества элементов в стеке (numberElements) - O(1).
### Для чего лучше всего подходит контейнер стек
Используется для обхода структур данных, например, дерево или граф. 
Таже при использовании рекурсивных функций будет применяться стек, но его аппаратный вид. 
Кроме того стек используется для организации стековой машины, реализующей вычисления в обратной 
польской записи. 

