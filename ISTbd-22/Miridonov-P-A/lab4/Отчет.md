# Отчет по лабораторной работе №4

### Исходный код:
```
#include <iomanip>
#include <iostream>
using namespace std;

void ArrayRandFill(int array[], int amount)
{
    srand((unsigned)time(0));
    for (int i = 0; i < amount; i++)
    {
        array[i] = rand() % 10;
    }
}

void ArrayOut(int array[], int amount)
{
    for (int i = 0; i < amount; i++)
    {
        cout << array[i] << " ";
    }
    cout << endl;
}

void Heap(int array[], int amount, int i)
{
    int largestElement = i;

    int a = 2 * i + 1;
    int b = 2 * i + 2;

    if ((a < amount) && (array[a] > array[largestElement])) largestElement = a;

    if ((b < amount) && (array[b] > array[largestElement])) largestElement = b;

    if (largestElement != i)
    {
        swap(array[i], array[largestElement]);
        Heap(array, amount, largestElement);
    }
}

void HeapSort(int array[], int amount)
{
    for (int i = amount / 2 - 1; i >= 0; i--)
        Heap(array, amount, i);

    for (int i = amount - 1; i > 0; i--)
    {
        swap(array[0], array[i]);
        Heap(array, i, 0);
    }
}

int main()
{
    setlocale(LC_ALL, "Russian");
    int amount;

    cout << "Введите количество элементов в массиве: ";
    cin >> amount;

    int* Array = new int[amount];

    ArrayRandFill(Array, amount);

    cout << "Массив: ";
    ArrayOut(Array, amount);

    HeapSort(Array, amount);

    cout << "Отсортированный массив: ";
    ArrayOut(Array, amount);
}
```
## Ответы на вопросы
### Что такое бинарное сортирующее дерево?
Бинарное дерево поиска - бинарное дерево из элементов, где ключ элемента в каждой вершине больше ключей всех элементов 
левого поддерева и меньше ключей элементов правого поддерева.В корне будет находиться элемент со средним индексом, элементы со 
средними индексами верхней и нижней половин таблицы составят значения левого и правого сыновей корня, следующий уровень 
вершин составят средние элементы всех четвертей таблицы и так далее.
### Суть пирамидального алгоритма сортировки
Сначала строится пирамида из элементов исходного массива, а затем осуществляется сортировка элементов. 
Определяем правую часть дерева, начиная с n/2-1. Далее берем элемент левее этой части массива и 
просеиваем его сквозь пирамиду по пути, где находятся меньшие его элементы, 
которые одновременно поднимаются вверх; из двух возможных путей выбираем путь через меньший элемент. 
Берем последний элемент массива в качестве текущего. Меняем верхний (наименьший) элемент массива и текущий местами. 
Текущий элемент (он теперь верхний) просеиваем сквозь n-1 элементную пирамиду. Затем берем предпоследний элемент и т.д. 
### В чем разница устойчивой и неустойчивой сортировки?
Устойчивая сортировка — сортировка, которая не меняет "местами" эквивалентные элементы.
Некоторые алгоритмы сортировки стабильны по своей природе, например, сортировка вставки, сортировка слияния, сортировка 
пузырьков и т. д. И некоторые алгоритмы сортировки не являются такими, как сортировка кучи, быстрая сортировка и т. д.
### Достоинства и недостатки
Достоинства - имеет доказанную оценку худшего случая O(n \log n), требует всего O(1) дополнительной памяти.
Недостатки - сложен в реализации, неустойчив, на почти отсортированных массивах работает столь же долго, как и на хаотических данных.