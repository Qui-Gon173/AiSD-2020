# <center>Лаболаторная работа №3 </center> 
## <center>"Реализовать сортировку методом Хоара."</center>   
## <strong>Задание: На языке C++ реализовать сортировку методом Хоара.   
## Исходный код:  
```
#include <iostream>
#include <time.h>
#include <cmath>
using namespace std;

void ArrayFill(int count, int array[])
{
    for (int i = 0; i < count; i++)
    {
        cin >> array[i];
    }
}


void ArrayOut(int count, int array[])
{
    for (int i = 0; i < count; i++)
    {
        cout << array[i] << " ";
    }
    cout << "\n";
}

void HoareSort(int array[], int last)
{
    int i = 0, j = last, center;
    center = array[last >> 1];

    do {
        while (array[i] < center) i++;
        while (array[j] > center) j--;

        if (i <= j)
        {
            swap(array[i], array[j]);
            i++; j--;
        }
    } while (i <= j);
    if (j > 0) HoareSort(array, j);
    if (last > i) HoareSort(array + i, last - i);
}

int main()
{
    setlocale(LC_ALL, "Russian");
    int array[20];
    int n;
    int left = 0, element;
    cout << " Введите кол-во элементов массива:   ";
    cin >> n;
    int right = n;
    cout << " Введите элементы массива:   ";
    ArrayFill(n, array);
    cout << " Массив:   ";
    ArrayOut(n, array);
    int last = n - 1;
    HoareSort(array, last);
    cout << " Отсортированный массив пользователем:   ";
    ArrayOut(n, array);
}
```  
## Вопросы к лаболаторной работе №3  
1. 	Учёный, специализирующийся в области информатики и вычислительной техники. Наиболее известен как разработчик алгоритма «быстрой сортировки» (1960), на сегодняшний день являющегося наиболее популярным алгоритмом сортировки.  
2. 	Метод основывается на последовательном разделении сортируемого набора данных на блоки меньшего размера таким образом, что между значениями разных блоков обеспечивается отношение упорядоченности.
3.	Алгоритм быстрой сортировки Хоара    
	<center>Пусть дан массив ```a[i]``` размерности ```n```. </center>  
    1. Шаг 1. Выбирается опорный элемент массива.  
	2. Шаг 2. Массив разбивается на два – левый и правый – относительно опорного элемента. Реорганизуем массив таким образом, чтобы все элементы, меньшие опорного элемента, оказались слева от него, а все элементы, большие опорного – справа от него.  
	3. Шаг 3. Далее повторяется шаг 2 для каждого из двух вновь образованных массивов. Каждый раз при повторении преобразования очередная часть массива разбивается на два меньших и т. д., пока не получится массив из двух элементов.  
4. Опорным элементом называется элемент массива, который выбирается определенный образом. С точки зрения теории алгоритма выбор элемента безразличен. С точки зрения практики алгоритма выбираться должна медиана, но без дополнительных сведений о сортируемых данных ее обычно невозможно получить. Необходимо выбирать постоянно один и тот же элемент или выбирать элемент со случайно выбранным индексом.  
5. Разбиение Ломуто
В коде выбирается последний элемент, алгоритм сохраняет индекс в переменную ```i```. Каждый раз, когда находится элемент, меньше или равный опорному, индекс увеличивается, и элемент вставляется перед опорным.  
6. Разбиение Хоара  
Используются два индекса (один в начале массива, другой в конце), которые приближаются друг к другу, пока не найдётся пара элементов, где один больше опорного и расположен перед ним, а второй меньше и расположен после. Эти элементы меняются местами. Обмен происходит до тех пор, пока индексы не пересекутся. Алгоритм возвращает последний индекс.  
7. Быстрая сортировка является наиболее эффективным алгоритмом из всех известных методов сортировки, но все усовершенствованные методы имеют один общий недостаток – невысокую скорость работы при малых значениях ```n```.
Рекурсивная реализация быстрой сортировки позволяет устранить этот недостаток путем включения прямого метода сортировки для частей массива с небольшим количеством элементов. 
8. https://www.youtube.com/watch?v=ywWBy6J5gz8






