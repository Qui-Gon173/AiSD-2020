# Лабораторная работа №4. Реализовать пирамидальный алгоритм сортировки

``` c++
#include <iostream>
#include <ctime>
using namespace std;
const int SIZE = 15;

//Функция преобразования в двоичную кучу
void podgotovSort(int* arr, int n, int i);
//Функция пирамидальной сортировки
void pyramidSort(int* arr, int n);

int main()
{
    setlocale(LC_ALL, "rus");
    int* massive = new int[SIZE];
    int minDiaposon = 0, maxDiaposon = 100;

    cout << "Исходный массив:" << endl;
    srand(time(0));
    //Заполняю массив случайными числами:
    for (int i = 0; i < SIZE; i++)
    {
        massive[i] = minDiaposon + rand() % (maxDiaposon - minDiaposon + 1);
        //Вывожу элементы массива на экран:
        cout << massive[i] << " ";
    }

    //Вызываю функцию сортировки:
    pyramidSort(massive, SIZE);

    //Вывожу отсортированные элементы массива:
    cout << endl << "Получившийся массив:" << endl;
    for (int i = 0; i < SIZE; i++)
    {
        cout << massive[i] << " ";
    }
    system("pause");
    return 0;
}


void podgotovSort(int* arr, int n, int i)
{
    int biggest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[biggest])
    {
        biggest = left;
    }
    if (right < n && arr[right] > arr[biggest])
    {
        biggest = right;
    }
    if (biggest != i)
    {
        int newValue = arr[i];
        arr[i] = arr[biggest];
        arr[biggest] = newValue;
        
        podgotovSort(arr, n, biggest);
    }
}


void pyramidSort(int* arr, int n)
{
    for (int i = (n / 2 - 1); i >= 0; i--)
        podgotovSort(arr, n, i);

    for (int i = n - 1; i >= 0; i--)
    {
        int newValue = arr[0];
        arr[0] = arr[i];
        arr[i] = newValue;
        podgotovSort(arr, i, 0);
    }
}
```

## Ответы на вопросы

- Что такое бинарное сортирующее дерево?
Это двоичное дерево, для которого выполняются следующие условия: 1) значение в людом корне не меньше, чем значения его потомков; 2) глубина всех расстояний от потомков до корня  отличается не более чем на 1; 3) последний слой заполняется слева направо без дырок. 

- Суть пирамидального алгоритма сортировки
Идея данной сортировки заключается в том, что сначала строится пирамида из элементов исходного массива, а затем осуществляется их сортировка. Алгоритм состоит из двух этапов.
На первом строится пирамида. Определяется правая часть дерева, начиная с нижнего уровня дерева (n/2-1). Элемент, находящийся левее этой части массива, просеивается сквозь пирамиду по пути, где находятся меньшие его элементы, которые одновременно поднимаются вверх; из двух возможных путей выбирается путь через меньший элемент.
На втором этапе происходит сортировка на пирамиде. Последний элемент массива считается текущим. Наименьший и текущий элементы массива меняются местами. Текущий элемент просеивается сквозь n-1 элементную пирамиду. После берется предпоследний элемент и т.д.

- В чем разница устойчивой и неустойчивой сортировки?
При устойчивой сортировке порядок элементов с одинаковыми ключами сохраняется, а при неустойчивой - теряется. Это наблюдается в пирамидальной сортировке и в сортировке методом Хоара.

- Достоинства и недостатки
"+" - сортировка не требует дополнительной памяти, имеет доказанную оценку худшего случая О(n * log n)
"-" - неустойчив, на почти отсортированных массивах работает столь же долго, как и на хаотических данных, методу требуется «мгновенный» прямой доступ