# Лабораторная работа №4
## Пирамидальный алгоритм сортировки
## Код сортировки
~~~ 
void SiftingDown(int array[], int root, int bottom)
{
    int maxChild;
    int done = 0;
    while ((root*2 <= bottom) && (!done))
    {
        if (root*2 == bottom)
            maxChild = root*2;
        else if (array[root*2] > array[root*2 + 1])
            maxChild = root*2;
        else
            maxChild = root * 2 + 1;
        if (array[root] < array[maxChild])
        {
            int tmp = array[root];
            array[root] = array[maxChild];
            array[maxChild] = tmp;
            root = maxChild;
        }
        else
            done = 1;
    }
}

void heapSort(int array[], int size)
{
    for (int i = (size/2) - 1; i >= 0; i--)
        SiftingDown(array, i, size - 1);
    for (int i = size - 1; i >= 0; i--)
    {
        int tmp = array[0];
        array[0] = array[i];
        array[i] = tmp;
        SiftingDown(array, 0, i - 1);
    }
}
~~~
---
## Что такое бинарное сортирующее дерево?
Сортирующее дерево – двоичное дерево с упорядоченными листьями, а его корень наибольший или наименьший элемент(Рис. 9.1 Элемент 1). Пирамиду можно представить в виде массива. 
такое двоичное дерево, для которого выполнены три условия:
- Значение в любой вершине не меньше, чем значения её потомков
- Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой
- Последний слой заполняется слева направо без «дырок»
![Сортирующее дерево](/SortTree.png)
---
## Суть пирамидального алгоритма сортировки
Идея пирамидальной сортировки заключается в том, чтобы построить пирамиду из исходного массива и "просеять" её.  
Построение пирамиды зависит от ключа сортировки, первый элемент может быть наибольшим или наименьшим.  
Просеивание - это построение новой пирамиды по следующему алгоритму: новый элемент помещается в вершину дерева, далее он перемещается по пути вниз на основе сравнения с дочерними элементами. Спуск завершается, если результат сравнения с дочерними элементами соответствует ключу сортировки.


---
## В чем разница устойчивой и неустойчивой сортировки?
Разница заключается в том, что при устройчивой сортировке, элементы имеющие одинаковые ключи, не меняют свой порядок, а при неустойчивой сортировке этот порядок теряется.


---
## Достоинства и недостатки
Достоинства:
- Имеет доказанную оценку худшего случая O(n * log n).
- Сортирует на месте, то есть требует всего O(1) дополнительной памяти.

Недостатки:
- Сложен в реализации.
- Является неустойчивым.
- На почти отсортированных массивах работает столь же долго, как и на хаотических данных.
- Ко­гда ко­ли­че­ство сор­ти­руе­мых дан­ных на­чи­на­ет пре­вы­шать раз­мер кэ­ша ско­рость сор­ти­ров­ки па­да­ет.
- Не работает на связанных списках и других структурах памяти последовательного доступа.


