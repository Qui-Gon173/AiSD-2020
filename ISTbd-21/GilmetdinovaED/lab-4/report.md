# Лабораторная работа №4

## ГильметдиноваЕД ИСТбд-21

## Цель

Реализовать пирамидальный алгоритм сортировки.

## Ход работы

_Реализация_:  
void Heapify(int arr[], int n, int i) // функция "просеивания"  
{  
    int maximum = i; // Инициализация наибольшего корня  
    int left = 2*i + 1; // левый потомок  
    int right = 2*i + 2; // правый потомок


    if (left < n && arr[left] > arr[maximum]) // Если левый дочерний элемент больше корня
       maximum = left; //то наибольший корень полагаем равным этому элементу


    if (right < n && arr[right] > arr[maximum])// Если правый дочерний элемент больше "нового" корня
        maximum = right;


    if (maximum != i)// Если самый большой элемент не корень
    {
        swap(arr[i], arr[maximum]);// меняем значения

        Heapify(arr, n, maximum);// Рекурсивно преобразуем в двоичную кучу затронутое поддерево
    }
}

//Пирамидальная сортировка  
void HeapSort(int arr[], int n)  
{  
  // построение "кучи"  
    for (int i = n / 2 - 1; i >= 0; i--)  
       {  
            Heapify(arr, n, i);  
       }

   //извлекаем элемениты  
    for (int i=n-1; i>=0; i--)  
    {
        swap(arr[0], arr[i]); // Перемещаем текущий корень в конец  
        Heapify(arr, i, 0);// вызываем процедуру просеивания на уменьшенной куче  
    }
}

## Контроьные вопросы

### Что такое бинарное сортирующее дерево?

Двоичное дерево с упорядоченными листьями(элементами), где корень дерева - наименьший или наибольший элемент.

### Суть пирамидального алгоритма сортировки

Сначала строится пирамида из элементов исходного массива, а затем осуществляется сортировка элементов.

### В чем разница устойчивой и неустойчивой сортировки?

* неустойчивая сортировка не может работать с большими объемами данных из-за угрозы переполнения стека
* устойчивая сортировка не меняет "местами" эквивалентные элементы
* устойчивая сортировка "ошибается" реже, отсюда и название
* устойчивая сортировка имеет постоянную вычислительную сложность (О(n)), в то время как неустойчивая варьируется в зависимости от исходных данных.  

### Достоинства и недостатки

Достоинства:
* Имеет доказанную оценку худшего случая O(n * log n).
* Сортирует на месте, то есть требует всего O(1) дополнительной памяти.

Недостатки:
* Сложен в реализации.
* Является неустойчивым
* На почти отсортированных массивах работает столь же долго, как и на хаотических данных.
* Ко­гда ко­ли­че­ство сор­ти­руе­мых дан­ных на­чи­на­ет пре­вы­шать раз­мер кэ­ша ско­рость сор­ти­ров­ки па­да­ет.
* Не работает на связанных списках и других структурах памяти последовательного доступа.